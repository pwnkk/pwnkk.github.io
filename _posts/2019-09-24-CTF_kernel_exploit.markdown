---
layout: post
title:  "CTF内核题目环境配置"
date:   2019-09-10 18:54:00
categories: pwn
tags: pwn
excerpt: CTF内核题目环境配置
mathjax: true
---

### 0x00 基础知识
```
常用函数
copy_from_user(*to,*from,unsigned long n) 实现了将用户空间的数据传送到内核空间
copy_to_user() 实现了将内核空间的数据传送到用户空间

修改权限的函数 
int commit_creds(struct cred *new)
struct cred prepare_kernel_cred(struct task_struct daemon)
执行 commit_creds(prepare_kernel_cred(0)) 即可获得root权限 

ioctl 用于与设备通信的系统调用
int ioctl(int fd, unsigned long request, ...)
fd 是open打开设备返回的描述符 ， 参数2是用户对设备的控制命令

```

内核使用cred 结构体判断进程权限，每个进程都有cred结构体，包含了uid，gid等
```
struct cred {
    atomic_t    usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
    atomic_t    subscribers;    /* number of processes subscribed */
    void        *put_addr;
    unsigned    magic;
#define CRED_MAGIC  0x43736564
#define CRED_MAGIC_DEAD 0x44656144
#endif
    kuid_t      uid;        /* real UID of the task */
    kgid_t      gid;        /* real GID of the task */
    kuid_t      suid;       /* saved UID of the task */
    kgid_t      sgid;       /* saved GID of the task */
    kuid_t      euid;       /* effective UID of the task */
    kgid_t      egid;       /* effective GID of the task */
    kuid_t      fsuid;      /* UID for VFS ops */
    kgid_t      fsgid;      /* GID for VFS ops */
    unsigned    securebits; /* SUID-less security management */
    kernel_cap_t    cap_inheritable; /* caps our children can inherit */
    kernel_cap_t    cap_permitted;  /* caps we're permitted */
    kernel_cap_t    cap_effective;  /* caps we can actually use */
    kernel_cap_t    cap_bset;   /* capability bounding set */
    kernel_cap_t    cap_ambient;    /* Ambient capability set */
#ifdef CONFIG_KEYS
    unsigned char   jit_keyring;    /* default keyring to attach requested
                     * keys to */
    struct key __rcu *session_keyring; /* keyring inherited over fork */
    struct key  *process_keyring; /* keyring private to this process */
    struct key  *thread_keyring; /* keyring private to this thread */
    struct key  *request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
    void        *security;  /* subjective LSM security */
#endif
    struct user_struct *user;   /* real user ID subscription */
    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
    struct group_info *group_info;  /* supplementary groups for euid/fsgid */
    struct rcu_head rcu;        /* RCU deletion hook */
} __randomize_layout;
```
查看linux内核源码的网站
https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118


查看内核函数地址
```
/ $ grep prepare_kernel /proc/kallsyms
ffffffff810a1810 T prepare_kernel_cred
ffffffff81d91890 R __ksymtab_prepare_kernel_cred
ffffffff81dac968 r __kcrctab_prepare_kernel_cred
ffffffff81db9450 r __kstrtab_prepare_kernel_cred
/ $ grep commit_creds /proc/kallsyms
ffffffff810a1420 T commit_creds
ffffffff81d88f60 R __ksymtab_commit_creds
ffffffff81da84d0 r __kcrctab_commit_creds
ffffffff81db948c r __kstrtab_commit_creds
```


### 0x01 环境准备
在ubuntu16.04中搭建内核pwn环境
1. 自编译内核代码
下载了较新版本的内核 linux-4.4.101.tar.gz
https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/
编译
```
tar zxvf linux-4.4.101.tar.gz
apt-get install libncurses5-dev build-essential kernel-package
cd linux-4.4.101
make menuconfig

```
开启选项
Kernel hacking  ==>  Compile-time checks and compiler options  ==> Compile the kernel with frame pointers
                                                               ==>  Compile the kernel with debug info
                ==>  KGDB: kernel debugger  
关闭选项
                ==>  Write protect kernel read-only data structures （取消）

```
make && make modules_install && make install
```

2. 编译busybox
```
wget https://busybox.net/downloads/busybox-1.29.3.tar.bz2
tar jxvf busybox-1.29.3.tar.bz2
make menuconfig
#开启
#Settings ==>  Build static binary (no shared libs)
#关闭
#Networking Utilities ==>   inetd (18 kb)
make && make install
```
在_install  目录下有编译好的文件
```
cd _install
mkdir proc sys dev etc etc/init.d
vim etc/init.d/rcS
chmod +x etc/init.d/rcS
```
rcS
```
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
```
最后在_install 目录创建文件系统
```
find . | cpio -o --format=newc > ../rootfs.img
```

qemu加载linux内核和busybox
```
qemu-system-x86_64 -kernel /home/pwn/kernel/linux-4.4.101/arch/x86_64/boot/bzImage -initrd /home/pwn/kernel/busybox-1.29.3/rootfs.img -append "console=ttyS 0 root=/dev/ram rdinit=/sbin/init" -cpu kvm64,+smep,+smap --nographic -gdb tcp::1234
```

退出qemu `ctrl + A   加X` 

模块操作
```
insmod: 将指定模块加载到内核中
rmmod: 从内核中卸载指定模块
lsmod: 列出已经加载的模块
```

### 0x02 编写驱动入门
编写一个驱动和一个c程序和驱动交互
编写hello.c
```
#include <linux/init.h>
#include <linux/module.h>

static int hello_init(void)
{
    printk(KERN_ALERT "Hello world\n");
    return 0;
}

static int hello_exit(void){
    printk(KERN_ALERT "Goodbye kernel");
}
module_init(hello_init);
module_exit(hello_exit);
```
编写makefile
`obj-m := hello.o`
如果有2个文件的话
```
obj-m := module.o
module-objs := file1.o file2.o
```

编译需要指定内核代码树的路径，编译出对应内核的module
```
make -C ~/kernel/linux-4.4.101 M=`pwd` modules
```
编译过后出现hello.ko

安装模块 insmod hello.ko 
insmod: ERROR: could not insert module hello.ko: Invalid module format
显示格式错误，这是因为系统内核和源码的内核版本不一致导致的

尝试在qemu中载入内核
将hello.ko 放到busybox目录下的_install/lib/ 中
etc/init.d/rcS如下
```
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev
#/sbin/mdev -s  为驱动创建文件节点 
insmod /lib/hello.ko
```
创建文件系统
`find . | cpio -o --format=newc > ../rootfs.img`

将rootfs.img 和 bzImage 都放到当前目录下
执行启动脚本run.sh
```
qemu-system-x86_64 -kernel ./bzImage -initrd ./rootfs.img -append "console=ttyS 0 root=/dev/ram rdinit=/sbin/init" -cpu kvm64,+smep,+smap --nographic -gdb tcp::1234
```

### 0x03 调试内核模块

如何给模块中的函数下断点 
1. 先从内核机器中读取基地址 
```
grep 0 /sys/module/hello/sections/.text 
0xffffffffc0005000
```
2. 在宿主机的gdb中载入内核模块，加上基地址

```
gdb-peda$ add-symbol-file /home/pwn/kernel/module_demo/hello/hello.ko 0xffffffffc0005000
add symbol table from file "/home/pwn/kernel/module_demo/hello/hello.ko" at
        .text_addr = 0xffffffffc0005000
Reading symbols from /home/pwn/kernel/module_demo/hello/hello.ko...done.
gdb-peda$ b *hello_init
Breakpoint 1 at 0xffffffffc0005000: file /home/pwn/kernel/module_demo/hello/hello.c, line 5.
```
如果有bss和data段的地址也可以加上
add-symbol-file /home/pwn/kernel/module_demo/hello/hello.ko 0xffffffffc0000000 -s .bss bss_addr -s .data data_addr 


gdb内核调试问题：
1. 出现reply过长的问题
set architecture i386:x86-64:intel


### 参考链接

