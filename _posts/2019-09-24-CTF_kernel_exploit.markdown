---
layout: post
title:  "CTF内核题目入门"
date:   2019-09-24 13:54:00
categories: pwn
tags: pwn
excerpt: 内核入门/CTF内核题目环境配置
mathjax: true
---

* content
{:toc}

### Overview 
在现代CTF中做多了用户态的堆栈溢出题目，如何平稳过渡到内核漏洞利用一直是比较头疼的事情。
在说环境配置之前需要先铺垫一下什么是内核以及和用户态利用有哪些区别。


### 0x00 基础知识

#### 1. 什么是内核
* 两点主要功能：1.控制并与硬件进行交互  2. 提供程序的运行环境
* Loadable Kernel Modules(LKMs) 可加载的内核模块，一般是驱动或内核扩展，可以单独编译但是要被加载到内核中执行。加载内核模块的三个命令
  + insmod 将模块加载到内核中
  + rmmod 卸载
  + lsmod 列出已经加载的模块

* 系统调用：linux系统调用是内核封装给用户态程序的接口，系统调用号定义在文件 unistd_64.h / unistd_32.h 中
* 内存空间：内核有自己独立的内存空间,比用户态地址高
![vmmap](IMG/CTF_kernel_exploit/vmmap2.png)

#### 2. 内核模块编写
用户程序通过设备文件和内核模块交互，例如open,close 都对应着模块中的某些函数。

* 常见内核函数
copy_from_user(void *to, const void *from, unsigned long n); 将用户空间的数据传送到内核空间
copy_to_user(void *to, const void *from, unsigned long n) 将内核空间的数据传送到用户空间
ioctl(int fd, unsigned long request, ...) 对设备的I/O通道进行管理,fd 是open打开设备返回的描述符,参数2是用户对设备的控制命令

* 环境准备: 先编译内核和busybox, 测试系统 ubuntu16.04

1. 编译内核代码

```
wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.101.tar.gz
tar zxvf linux-4.4.101.tar.gz
apt-get install libncurses5-dev build-essential kernel-package
cd linux-4.4.101
make menuconfig
```

开启选项
Kernel hacking  ==>  Compile-time checks and compiler options  ==> Compile the kernel with frame pointers
                                                               ==>  Compile the kernel with debug info
                ==>  KGDB: kernel debugger  
关闭选项
                ==>  Write protect kernel read-only data structures （取消）

`make && make modules_install && make install`

2. 编译busybox

```
wget https://busybox.net/downloads/busybox-1.29.3.tar.bz2
tar jxvf busybox-1.29.3.tar.bz2
make menuconfig
#开启
#Settings ==>  Build static binary (no shared libs)
#关闭
#Networking Utilities ==>   inetd (18 kb)
make && make install
```
在_install  目录下有编译好的文件

```sh
cd _install
mkdir proc sys dev etc etc/init.d
vim etc/init.d/rcS
chmod +x etc/init.d/rcS
```

rcS内容
```sh
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
/sbin/mdev -s
```
在_install 目录创建文件系统 `find . | cpio -o --format=newc > ../rootfs.img`

qemu加载linux内核和busybox
```
qemu-system-x86_64 -kernel /home/pwn/kernel/linux-4.4.101/arch/x86_64/boot/bzImage -initrd /home/pwn/kernel/busybox-1.29.3/rootfs.img -append "console=ttyS 0 root=/dev/ram rdinit=/sbin/init" -cpu kvm64,+smep,+smap --nographic -gdb tcp::1234
```
退出qemu `ctrl + A 加X` 

3. 编写hello world
我们可以编写一个小demo来体验一下内核相关的编译调试



### 0x01 内核漏洞利用

内核漏洞利用是编写用户态程序与内核交互，利用驱动等内核漏洞获取内核控制权，修改进程权限，再返回到用户态获得高权限进程。

1. 内核与用户态切换
为什么要再返回到用户态?
一些在用户态很轻易做的事情，在内核中变得不太容易。比如，修改文件，创建进程，联网等

* 进入内核
```
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;

static void save_state() {
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
	: "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");
}
```

* 离开内核
![](IMG/CTF_kernel_exploit/kernelrop.png)
截取exp的片段

```
    *fake_stack ++= 0xffffffff81052804UL; // swapgs ; pop rbp ; ret
    *fake_stack ++= 0xdeadbeefUL;         // dummy placeholder 
	*fake_stack ++= 0xffffffff81053056UL; /* iretq */
	*fake_stack ++= (unsigned long)shell; /* spawn a shell */
	*fake_stack ++= user_cs;              /* saved CS */
	*fake_stack ++= user_rflags;          /* saved EFLAGS */
	*fake_stack ++= (unsigned long)(temp_stack+0x5000000);  /* mmaped stack region in user space */
    *fake_stack ++= user_ss;              /* saved SS */
```
如果利用kernel_rop 

+ 通过swapgs恢复GS值。
+ 通过sysretq或者iretq恢复到用户空间进行执行，如果使用iretq还需要给出用户空间的一些信息，比如CS值，eflags标志寄存器值，用户栈顶位置等等信息。

```
常用函数

修改权限的函数 
int commit_creds(struct cred *new)
struct cred prepare_kernel_cred(struct task_struct daemon)
执行 commit_creds(prepare_kernel_cred(0)) 即可获得root权限 
```

内核使用cred 结构体判断进程权限，每个进程都有cred结构体，包含了uid，gid等

```
struct cred {
    atomic_t    usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
    atomic_t    subscribers;    /* number of processes subscribed */
    void        *put_addr;
    unsigned    magic;
#define CRED_MAGIC  0x43736564
#define CRED_MAGIC_DEAD 0x44656144
#endif
    kuid_t      uid;        /* real UID of the task */
    kgid_t      gid;        /* real GID of the task */
    kuid_t      suid;       /* saved UID of the task */
    kgid_t      sgid;       /* saved GID of the task */
    kuid_t      euid;       /* effective UID of the task */
    kgid_t      egid;       /* effective GID of the task */
    kuid_t      fsuid;      /* UID for VFS ops */
    kgid_t      fsgid;      /* GID for VFS ops */
    unsigned    securebits; /* SUID-less security management */
    kernel_cap_t    cap_inheritable; /* caps our children can inherit */
    kernel_cap_t    cap_permitted;  /* caps we're permitted */
    kernel_cap_t    cap_effective;  /* caps we can actually use */
    kernel_cap_t    cap_bset;   /* capability bounding set */
    kernel_cap_t    cap_ambient;    /* Ambient capability set */
#ifdef CONFIG_KEYS
    unsigned char   jit_keyring;    /* default keyring to attach requested
                     * keys to */
    struct key __rcu *session_keyring; /* keyring inherited over fork */
    struct key  *process_keyring; /* keyring private to this process */
    struct key  *thread_keyring; /* keyring private to this thread */
    struct key  *request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
    void        *security;  /* subjective LSM security */
#endif
    struct user_struct *user;   /* real user ID subscription */
    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
    struct group_info *group_info;  /* supplementary groups for euid/fsgid */
    struct rcu_head rcu;        /* RCU deletion hook */
} __randomize_layout;
```

查看linux内核源码的网站
https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118


查看内核函数地址

```
/ $ grep prepare_kernel /proc/kallsyms
ffffffff810a1810 T prepare_kernel_cred
ffffffff81d91890 R __ksymtab_prepare_kernel_cred
ffffffff81dac968 r __kcrctab_prepare_kernel_cred
ffffffff81db9450 r __kstrtab_prepare_kernel_cred
/ $ grep commit_creds /proc/kallsyms
ffffffff810a1420 T commit_creds
ffffffff81d88f60 R __ksymtab_commit_creds
ffffffff81da84d0 r __kcrctab_commit_creds
ffffffff81db948c r __kstrtab_commit_creds
```


### 0x01 环境准备


### 0x02 编写驱动入门
编写一个驱动和一个c程序和驱动交互
编写hello.c

```
#include <linux/init.h>
#include <linux/module.h>

static int hello_init(void)
{
    printk(KERN_ALERT "Hello world\n");
    return 0;
}

static int hello_exit(void){
    printk(KERN_ALERT "Goodbye kernel");
}
module_init(hello_init);
module_exit(hello_exit);
```

编写makefile
`obj-m := hello.o`
如果有2个文件的话

```
obj-m := module.o
module-objs := file1.o file2.o
```

编译需要指定内核代码树的路径，编译出对应内核的module

```
make -C ~/kernel/linux-4.4.101 M=`pwd` modules
```

编译过后出现hello.ko

安装模块 insmod hello.ko 
insmod: ERROR: could not insert module hello.ko: Invalid module format
显示格式错误，这是因为系统内核和源码的内核版本不一致导致的,进入qemu后安装即可。

尝试在qemu中载入内核
将hello.ko 放到busybox目录下的_install/lib/ 中
etc/init.d/rcS如下

```
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev
#/sbin/mdev -s  为驱动创建文件节点 
insmod /lib/hello.ko
```

创建文件系统

`find . | cpio -o --format=newc > ../rootfs.img`

将rootfs.img 和 bzImage 都放到当前目录下
执行启动脚本run.sh

```
qemu-system-x86_64 -kernel ./bzImage -initrd ./rootfs.img -append "console=ttyS 0 root=/dev/ram rdinit=/sbin/init" -cpu kvm64,+smep,+smap --nographic -gdb tcp::1234
```

### 0x03 调试内核模块
如何给模块中的函数下断点 

* 先从内核机器中读取基地址

```
grep 0 /sys/module/hello/sections/.text 
0xffffffffc0005000
```

* 在宿主机的gdb中载入内核模块,加上基地址

```
gdb-peda$ add-symbol-file /home/pwn/kernel/module_demo/hello/hello.ko 0xffffffffc0005000
add symbol table from file "/home/pwn/kernel/module_demo/hello/hello.ko" at
        .text_addr = 0xffffffffc0005000
Reading symbols from /home/pwn/kernel/module_demo/hello/hello.ko...done.
gdb-peda$ b *hello_init
Breakpoint 1 at 0xffffffffc0005000: file /home/pwn/kernel/module_demo/hello/hello.c, line 5.
```

如果有bss和data段的地址也可以加上

```
add-symbol-file /home/pwn/kernel/module_demo/hello/hello.ko 0xffffffffc0000000 -s .bss bss_addr -s .data data_addr 
```

gdb内核调试问题:

1. 出现reply过长的问题
`set architecture i386:x86-64:intel`


### 参考链接
* [内核环境配置] (https://xz.aliyun.com/t/2024)
* [内核利用入门 anciety] (https://www.anquanke.com/post/id/86490)
* [Linux Kernel Exploitation](https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/kernel/ref/13_lecture.pdf)  

* https://github.com/vnik5287/kernel_rop/blob/master/rop_exploit.c
* https://devcraft.io/2018/04/25/blazeme-blaze-ctf-2018.html
